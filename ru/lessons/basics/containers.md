---
version: 1.3.1
title: ÐšÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ñ‹
---

ÐšÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸, ÑÐ¿Ð¸ÑÐºÐ¸, ÑÐ¿Ð¸ÑÐºÐ¸ Ð°ÑÑÐ¾Ñ†Ð¸Ð°Ñ†Ð¸Ð¹, Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð°, Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ / Ñ…ÑÑˆ-Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹, Ð²ÐµÐºÑ‚Ð¾Ñ€Ñ‹.

{% include toc.html %}

## ÐšÐ¾Ð³Ð´Ð° ÐºÐ°ÐºÐ¾Ð¹ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€ Ð±Ñ€Ð°Ñ‚ÑŒ

Ð’Ð½Ð°Ñ‡Ð°Ð»Ðµ Ð´Ð°Ð´Ð¸Ð¼ ÐºÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐµÐµ (Ð¾Ð´Ð½Ð¾ Ð¿Ñ€ÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð½Ð° ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€) Ñ€ÑƒÐºÐ¾Ð²Ð¾Ð´ÑÑ‚Ð²Ð¾ Ð¾ Ñ‚Ð¾Ð¼,
ÐºÐ¾Ð³Ð´Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÐºÐ°Ð¶Ð´Ñ‹Ð¹ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€. Ð’ÑÑ‘ Ð½ÐµÐ¿Ð¾Ð½ÑÑ‚Ð½Ð¾Ðµ Ð·Ð´ÐµÑÑŒ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð¿Ñ€Ð¾ÑÑÐ½Ð¸Ñ‚ÑŒÑÑ
Ð¿Ð¾ÑÐ»Ðµ Ð¿Ñ€Ð¾Ñ‡Ñ‚ÐµÐ½Ð¸Ñ Ð±Ð¾Ð»ÐµÐµ Ð³Ð»ÑƒÐ±Ð¾ÐºÐ¸Ñ… Ð¾Ð±ÑŠÑÑÐ½ÐµÐ½Ð¸Ð¹ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð° Ð´Ð°Ð»ÐµÐµ.

- Ð‘Ñ‹ÑÑ‚Ñ€Ð¾ ÑÐ³Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ„Ñ€Ð°Ð³Ð¼ÐµÐ½Ñ‚Ð¾Ð² Ð´Ð°Ð½Ð½Ñ‹Ñ…? Ð¡Ð¼Ð¾Ñ‚Ñ€Ð¸Ð¼ Ð½Ð° [ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸](#ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸)
- Ð‘Ñ‹ÑÑ‚Ñ€Ð¾Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð² Ð½Ð°Ñ‡Ð°Ð»Ð¾? Ð¡Ð¼Ð¾Ñ‚Ñ€Ð¸Ð¼ Ð½Ð° [ÑÐ¿Ð¸ÑÐºÐ¸](#ÑÐ¿Ð¸ÑÐºÐ¸)
- Ð£Ð½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ðµ Ð¸ Ð¾Ñ‚ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹? Ð¡Ð¼Ð¾Ñ‚Ñ€Ð¸Ð¼ Ð½Ð° [Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð°](#Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð°)
- Ð˜ÑÐºÐ°Ñ‚ÑŒ ÐºÐ»ÑŽÑ‡ Ð² ÑÐ¾Ð¿Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ð¸ "ÐºÐ»ÑŽÑ‡-Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ"? Ð¡Ð¼Ð¾Ñ‚Ñ€Ð¸Ð¼ Ð½Ð° [Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ](#Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ)
- Ð‘Ñ‹ÑÑ‚Ñ€Ð°Ñ Ð¸Ð½Ð´ÐµÐºÑÐ°Ñ†Ð¸Ñ? Ð¡Ð¼Ð¾Ñ‚Ñ€Ð¸Ð¼ Ð½Ð° [Ð²ÐµÐºÑ‚Ð¾Ñ€Ð°](#Ð²ÐµÐºÑ‚Ð¾Ñ€Ð°)

## Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð½Ñ‹Ñ… Ð¼Ð¾Ð´ÑƒÐ»ÐµÐ¹

ÐŸÑ€Ð¸ÑÑ‚Ð½Ð°Ñ Ð¾ÑÐ¾Ð±ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ ÑÐºÐ¾ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð¾Ð² Ð² Haskell Ð·Ð°ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ÑÑ Ð² Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ Ð²ÑÐµ
Ð¼Ð¾Ð´ÑƒÐ»Ð¸ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÑŽÑ‚ Ð¾Ñ‡ÐµÐ½ÑŒ ÑÑ…Ð¾Ð¶Ð¸Ð¹ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ. Ð­Ñ‚Ð¾ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ñ€Ð°Ð·Ð²Ð¸Ñ‚ÑŒ Ð¸Ð½Ñ‚ÑƒÐ¸Ñ†Ð¸ÑŽ Ð¸
Ð±Ñ‹ÑÑ‚Ñ€Ð¾ Ð¾ÑÐ²Ð¾Ð¸Ñ‚ÑŒ ÑˆÐ¸Ñ€Ð¾ÐºÐ¸Ð¹ Ð½Ð°Ð±Ð¾Ñ€ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð². Ð­Ñ‚Ð¾ Ñ‚Ð°ÐºÐ¶Ðµ Ð¾Ð·Ð½Ð°Ñ‡Ð°ÐµÑ‚ Ð½ÐµÐ¸Ð·Ð±ÐµÐ¶Ð½Ð¾ÑÑ‚ÑŒ
ÐºÐ¾Ð½Ñ„Ð»Ð¸ÐºÑ‚Ð¾Ð² Ð¸Ð¼Ñ‘Ð½. ÐÐ° Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¿Ñ€Ð¸Ñ…Ð¾Ð´Ð¸Ñ‚ Ð¿Ñ€Ð°ÐºÑ‚Ð¸ÐºÐ° ÐºÐ²Ð°Ð»Ð¸Ñ„Ð¸Ñ†Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð°.

Ð•ÑÐ»Ð¸ Ð²Ñ‹ ÑÐ¾Ð±Ð¸Ñ€Ð°ÐµÑ‚ÐµÑÑŒ Ð·Ð°Ð¿ÑƒÑÐºÐ°Ñ‚ÑŒ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ñ‹, Ð¿Ñ€Ð¸Ð²ÐµÐ´Ñ‘Ð½Ð½Ñ‹Ðµ Ð² ÑÑ‚Ð¾Ð¹ Ð³Ð»Ð°Ð²Ðµ, Ð½Ð° ÑÐ²Ð¾Ñ‘Ð¼
ÐºÐ¾Ð¼Ð¿ÑŒÑŽÑ‚ÐµÑ€Ðµ Ð² GHCi, Ð²Ð½Ð°Ñ‡Ð°Ð»Ðµ Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ðµ ÐºÐ²Ð°Ð»Ð¸Ñ„Ð¸Ñ†Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ñ‹, Ñ‡Ñ‚Ð¾Ð±Ñ‹
Ð²ÑÐµ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð½Ñ‹Ðµ Ð¼Ð¾Ð´ÑƒÐ»Ð¸ Ð¾ÐºÐ°Ð·Ð°Ð»Ð¸ÑÑŒ Ð¾Ð±Ð»Ð°ÑÑ‚Ð¸ Ð²Ð¸Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸.

```haskell
ghci> import Data.Set as Set
ghci> import Data.Map as Map
ghci> import Data.List.NonEmpty as NE
ghci> :t Map.empty
Map.empty :: Map k a
ghci> :t Set.empty
Set.empty :: Set.Set a
ghci> :t NE.head
NE.head :: NE.NonEmpty a -> a
```

ÐÐ° Ð²ÑÑÐºÐ¸Ð¹ ÑÐ»ÑƒÑ‡Ð°Ð¹ Ð¿Ñ€Ð¸Ð²ÐµÐ´Ñ‘Ð¼ Ð¿Ñ€Ð¸Ð¼ÐµÑ€ Ð¾ÑˆÐ¸Ð±ÐºÐµ, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð²Ð¾Ð·Ð½Ð¸ÐºÐ°ÐµÑ‚
ÐºÐ¾Ð³Ð´Ð° Ð²Ñ‹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚Ðµ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð½ÐµÐºÐ²Ð°Ð»Ð¸Ñ„Ð¸Ñ†Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð½Ñ‹Ñ… Ð¼Ð¾Ð´ÑƒÐ»ÐµÐ¹.

```haskell
ghci> import Data.List
ghci> import Data.Set
ghci> import Data.Map
ghci> lookup

<interactive>:4:1: error:
    Ambiguous occurrence â€˜lookupâ€™
    It could refer to
       either â€˜Data.Map.lookupâ€™,
              imported from â€˜Data.Mapâ€™
              (and originally defined in â€˜Data.Map.Internalâ€™)
           or â€˜Prelude.lookupâ€™,
              imported from â€˜Preludeâ€™ (and originally defined in â€˜GHC.Listâ€™)
ghci> empty

<interactive>:5:1: error:
    Ambiguous occurrence â€˜emptyâ€™
    It could refer to
       either â€˜Data.Map.emptyâ€™,
              imported from â€˜Data.Mapâ€™
              (and originally defined in â€˜Data.Map.Internalâ€™)
           or â€˜Data.Set.emptyâ€™,
              imported from â€˜Data.Setâ€™
              (and originally defined in â€˜Data.Set.Internalâ€™)
```

## ÐšÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸

Ð˜Ð·ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð¾Ð² Ð² Haskell Ð½Ð°Ñ‡Ð½Ñ‘Ð¼ Ñ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹. ÐžÐ½Ð¸ Ð¿Ñ€Ð¾ÑÑ‚Ñ‹, Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ñ‹ Ð² ÑÐ·Ñ‹Ðº Ð¸
Ð¸Ð¼ÐµÑŽÑ‚ Ð»Ð°ÐºÐ¾Ð½Ð¸Ñ‡Ð½Ñ‹Ð¹ ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ. Ð¡Ð¿Ð¾ÑÐ¾Ð± Ð¾Ð±Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ñ Ðº Ð¿Ð¾Ð»ÑŽ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð° Ð·Ð°Ð²Ð¸ÑÐ¸Ñ‚ Ð¾Ñ‚ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸
Ð¿Ð¾Ð»Ñ Ð² ÑÑ‚Ð¾Ð¹ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ðµ. Ð¥Ð¾Ñ‚Ñ Ñ‚ÐµÐ¾Ñ€ÐµÑ‚Ð¸Ñ‡ÐµÑÐºÐ¸ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ Ð¼Ð¾Ð³ÑƒÑ‚ ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð»ÑŽÐ±Ð¾Ðµ
ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ð½Ð° Ð¿Ñ€Ð°ÐºÑ‚Ð¸ÐºÐµ Haskell Report Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ Ð¾Ñ‚ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ ÑÐ·Ñ‹ÐºÐ° Ð½Ðµ
Ð¼ÐµÐ½ÐµÐµ 15 Ð¿Ð¾Ð»ÐµÐ¹, Ð° GHC Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼ 62 Ð¿Ð¾Ð»Ñ. ÐœÑ‹ ÑÐ¾ÑÑ€ÐµÐ´Ð¾Ñ‚Ð¾Ñ‡Ð¸Ð¼ÑÑ Ð½Ð°
Ð´Ð²ÑƒÑ…ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð½Ñ‹Ñ… ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð°Ñ…, Ð¿Ð¾ÑÐºÐ¾Ð»ÑŒÐºÑƒ Haskell Ð¸Ð¼ÐµÐµÑ‚ Ñ…Ð¾Ñ€Ð¾ÑˆÑƒÑŽ Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ð½ÑƒÑŽ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÑƒ
Ð´Ð»Ñ Ð½Ð¸Ñ…. ÐžÐ´Ð½Ð°ÐºÐ¾ Ð´Ð»Ñ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð° Ð¿Ð¾ÐºÐ°Ð¶ÐµÐ¼ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ Ñ 8 Ð¿Ð¾Ð»ÑÐ¼Ð¸.

```haskell
ghci> :t ('0', '1', '2', '3', '4', '5', '6', "8-tuple")
('0', '1', '2', '3', '4', '5', '6', "8-tuple")
  :: (Char, Char, Char, Char, Char, Char, Char, [Char])
```
__Ð—Ð°Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ__: ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° `:t` Ð² GHCi Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ñ‚Ð¸Ð¿ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ. ÐžÐ½Ð° Ñ€Ð°ÑÐ¿ÐµÑ‡Ð°Ñ‚Ð°ÐµÑ‚
ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ñ„Ð¾Ñ€Ð¼Ðµ `Ð²Ñ‹Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ :: Ð¢Ð¸Ð¿`.

### ÐšÐ¾Ð³Ð´Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ

ÐšÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ Ð¿Ð¾Ð»ÐµÐ·Ð½Ñ‹ Ð´Ð»Ñ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ¸ Ð´Ð°Ð½Ð½Ñ‹Ñ…; Ð¾Ð½Ð¸ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑŽÑ‚ ÑÐºÐ°Ð·Ð°Ñ‚ÑŒ: Â«ÐœÐ½Ðµ Ð½ÑƒÐ¶Ð½Ð¾ Ð¸ Ñ‚Ð¾, Ð¸
Ð´Ñ€ÑƒÐ³Ð¾Ðµ ÑÑ€Ð°Ð·ÑƒÂ». ÐšÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ Ð¿Ð¾Ð´Ñ‡Ñ‘Ñ€ÐºÐ¸Ð²Ð°ÑŽÑ‚ *ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñƒ* Ð´Ð°Ð½Ð½Ñ‹Ñ…, Ð° Ð½Ðµ Ð¸Ñ…
*Ð¿Ñ€ÐµÐ´Ð½Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ*, Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ Ð¸Ð½Ð¾Ð³Ð´Ð° ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ Ð¸Ð·Ð±ÐµÐ³Ð°ÑŽÑ‚. Ð•ÑÐ»Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‚ÑÑ Ð²
Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ñ… Ð¼ÐµÑÑ‚Ð°Ñ…, Ð·Ð°Ñ‡Ð°ÑÑ‚ÑƒÑŽ Ð»ÑƒÑ‡ÑˆÐµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð·Ð°Ð¿Ð¸ÑÑŒ. ÐžÐ´Ð½Ð°ÐºÐ¾ ÐµÑÐ»Ð¸ ÑÐ»ÑƒÑ‡Ð°Ð¹
Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ Ð»Ð¾ÐºÐ°Ð»ÐµÐ½ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, Ð² Ð¿Ñ€ÐµÐ´ÐµÐ»Ð°Ñ… Ð¾Ð±Ð»Ð°ÑÑ‚Ð¸ Ð²Ð¸Ð´Ð¸Ð¼Ð¾ÑÑ‚Ð¸ Ð¾Ð´Ð½Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸),
Ñ‚Ð¾Ð³Ð´Ð° ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¿Ñ€Ð¸Ð³Ð¾Ð´Ð¸Ñ‚ÑŒÑÑ!

### Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹

ÐšÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ ÑÐ¾Ð·Ð´Ð°ÑŽÑ‚, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ ÐºÑ€ÑƒÐ³Ð»Ñ‹Ðµ ÑÐºÐ¾Ð±ÐºÐ¸ Ñ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°Ð¼Ð¸, Ñ€Ð°Ð·Ð´ÐµÐ»ÐµÐ½Ð½Ñ‹Ð¼Ð¸ Ð·Ð°Ð¿ÑÑ‚Ð¾Ð¹
`(a, b)`.

```haskell
ghci> myTuple = (True, "hello")
ghci> :t myTuple
myTuple :: (Bool, [Char])
```

Ð¢Ð°ÐºÐ¶Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð»Ðµ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð° Ð¿ÑƒÑÑ‚Ñ‹Ð¼, Ð¸ ÑÑ‚Ð¾ Ð¿Ñ€ÐµÐ²Ñ€Ð°Ñ‚Ð¸Ñ‚ ÐµÐ³Ð¾ Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ. Ð¢Ð°ÐºÐ°Ñ
Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ° Ð½Ð°Ð·Ñ‹Ð²Ð°ÐµÑ‚ÑÑ ÑÐµÑ‡ÐµÐ½Ð¸ÐµÐ¼ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹. ÐžÐ½Ð° Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ðµ ÑÐ·Ñ‹ÐºÐ°
`TupleSections`.

```haskell
ghci> :set -XTupleSections
ghci> :t (True,)
(True,) :: t -> (Bool, t)
ghci> :t (,"hello")
(,"hello") :: t -> (t, String)
ghci> :t (,)
(,) :: a -> b -> (a, b)
ghci> (,) True "hello"
(True,"hello")
```
__Ð—Ð°Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ__: ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ ÑÐ·Ñ‹ÐºÐ¾Ð²Ð¾Ð³Ð¾ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ñ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ GHCi Ð²Ñ‹Ð³Ð»ÑÐ´Ð¸Ñ‚
Ñ‚Ð°Ðº: ÐºÐ»ÑŽÑ‡ÐµÐ²Ð¾Ðµ ÑÐ»Ð¾Ð²Ð¾ `:set` Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ GHCi ÑƒÐ·Ð½Ð°Ñ‚ÑŒ Ñ‡Ñ‚Ð¾ Ð¼Ñ‹ ÑƒÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ñ„Ð»Ð°Ð³
ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑ‚Ð¾Ñ€Ð°; Ð¿Ñ€ÐµÑ„Ð¸ÐºÑ `-X` ÑÐ¾Ð¾Ð±Ñ‰Ð°ÐµÑ‚ GHCi, Ñ‡Ñ‚Ð¾ Ð¼Ñ‹ Ð¾Ð±Ñ€Ð°Ñ‰Ð°ÐµÐ¼ÑÑ Ð·Ð° Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸ÐµÐ¼ ÑÐ·Ñ‹ÐºÐ°;
Ð² ÐºÐ¾Ð½Ñ†Ðµ ÑÐ»ÐµÐ´ÑƒÐµÑ‚ Ð¸Ð¼Ñ Ñ€Ð°ÑÑˆÐ¸Ñ€ÐµÐ½Ð¸Ñ.

### Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹

Ð”Ð»Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹ Ð¸Ñ… Ñ€Ð°Ð·Ð±Ð¸Ð²Ð°ÑŽÑ‚ Ð½Ð° Ñ‡Ð°ÑÑ‚Ð¸. Ð¡Ð°Ð¼Ñ‹Ð¹ Ñ€Ð°ÑÐ¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÐµÐ½Ð½Ñ‹Ð¹ Ð¿Ð¾Ð´Ñ…Ð¾Ð´
ÑÑ‚Ð¾ ÑÐ¾Ð¿Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ Ð¾Ð±Ñ€Ð°Ð·Ñ†Ð¾Ð¼ Ð¿Ð¾ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ðµ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð° Ñ Ð¿Ð¾ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð¾Ð¼ Ðº ÐµÐ³Ð¾
ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð°Ð¼. Ð¢Ð°ÐºÐ°Ñ Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ° Ñ…Ð¾Ñ€Ð¾ÑˆÐ° Ñ‚ÐµÐ¼, Ñ‡Ñ‚Ð¾ Ð¾Ð½Ð° Ð¾Ð±Ð¾Ð±Ñ‰Ð°ÐµÑ‚ÑÑ Ð½Ð° ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ Ð»ÑŽÐ±Ð¾Ð³Ð¾
Ñ€Ð°Ð·Ð¼ÐµÑ€Ð°.

```haskell
ghci> (\(a, b) -> not a) myTuple
False
ghci> (\(a, b) -> b <> " world") myTuple
"hello world"

ghci> (\(a, b, c) -> a <> " " <> b <> " " <> c) ("my", "name", "is")
"my name is"
```

Ð”Ð»Ñ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð° Ð¸Ð· Ð´Ð²ÑƒÑ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² ÐµÑÑ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ `fst` Ð¸ `snd` Ð¸Ð· ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ð¹
Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ¸. Ð”Ð²ÑƒÑ…ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð½Ñ‹Ðµ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ ÑÑ‚Ð¾ ÐµÐ´Ð¸Ð½ÑÑ‚Ð²ÐµÐ½Ð½Ð°Ñ Ñ€Ð°Ð·Ð½Ð¾Ð²Ð¸Ð´Ð½Ð¾ÑÑ‚ÑŒ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð°, Ð´Ð»Ñ
ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ Ð¸Ð¼ÐµÐµÑ‚ÑÑ Ñ‚Ð°ÐºÐ¾Ð³Ð¾ Ñ€Ð¾Ð´Ð° Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ð½Ð°Ñ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ°, Ð¿Ð¾ÑÑ‚Ð¾Ð¼Ñƒ, ÐµÑÐ»Ð¸ Ð²Ð°Ð¼ Ð½ÑƒÐ¶ÐµÐ½
ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ Ð¿Ð¾Ð±Ð¾Ð»ÑŒÑˆÐµ, Ð±ÑƒÐ´ÑŒÑ‚Ðµ Ð³Ð¾Ñ‚Ð¾Ð²Ñ‹ Ðº Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð¸ÑŽ ÑÐ²Ð¾Ð¸Ñ… ÑÐ¾Ð±ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð°.

```haskell
ghci> :t fst
fst :: (a, b) -> a
ghci> fst myTuple
True
ghci> :t snd
snd :: (a, b) -> b
ghci> snd myTuple
"hello"
```

### ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ñ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹

ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ðµ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ðµ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹ Ð² Haskell ÑÐ¾ÑÑ‚Ð¾Ð¸Ñ‚ Ð² Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð¸ Ñ€Ð°Ð·Ð½Ñ‹Ñ… Ð´Ð»Ð¸Ð½
ÑÑ‚Ð¾ Ñ€Ð°Ð·Ð»Ð¸Ñ‡Ð½Ñ‹Ðµ Ñ‚Ð¸Ð¿Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…. Ð¢Ð°ÐºÐ¸Ð¼ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð¼, Ð½ÐµÑ‚ Ð¾Ð±Ñ‰ÐµÐ¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ
Ð½Ð¾Ð²Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð° Ðº Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð»ÑŒÐ½Ð¾Ð¼Ñƒ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ñƒ. Ð‘Ð¾Ð»ÐµÐµ Ñ‚Ð¾Ð³Ð¾, Ñ‚Ð°ÐºÐ¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð´Ð¾Ð»Ð¶Ð½Ñ‹
Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÑ‚ÑŒÑÑ Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð° Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ð¾.

Ð’Ð¾Ñ‚ Ð¿Ñ€Ð¸Ð¼ÐµÑ€ ÑƒÐ²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð¸Ñ Ð´Ð»Ð¸Ð½Ñ‹ Ð´Ð²ÑƒÑ…ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð½Ð¾Ð³Ð¾ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð°.

```haskell
ghci> twoTupleToThreeTuple c (a, b) = (a, b, c)
ghci> twoTupleToThreeTuple () myTuple
(1, "world", ())
```

Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð°Ñ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÐ° Ð²Ñ‹Ð·Ð²Ð°Ñ‚ÑŒ Ð½Ð°ÑˆÑƒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð´Ð»Ñ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶Ð° Ð½ÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾Ð¹ Ð´Ð»Ð¸Ð½Ñ‹ Ð¿Ñ€Ð¸Ð²Ð¾Ð´Ð¸Ñ‚ Ðº
Ð¾ÑˆÐ¸Ð±ÐºÐµ Ñ‚Ð¸Ð¿Ð¾Ð², ÑÐ¾Ð¾Ð±Ñ‰Ð°ÑŽÑ‰ÐµÐ¹ Ð½Ð°Ð¼ Ð¿Ñ€ÑÐ¼Ð¾: Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð° 2-ÐºÐ¾Ñ€Ñ‚ÐµÐ¶, Ð° Ð¼Ñ‹ Ð¿ÐµÑ€ÐµÐ´Ð°Ð»Ð¸ ÐµÐ¹
3-ÐºÐ¾Ñ€Ñ‚ÐµÐ¶.

```haskell
ghci> twoTupleToThreeTuple True (1, 2, 3)

<interactive>:19:27: error:
    â€¢ Couldn't match expected type: (a, b)
                  with actual type: (a0, b0, c0)
                  ...
```

## Ð¡Ð¿Ð¸ÑÐºÐ¸

Ð¡ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð·Ñ€ÐµÐ½Ð¸Ñ ÑƒÐ´Ð¾Ð±ÑÑ‚Ð²Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÐ¿Ð¸ÑÐºÐ¸ Ñ€ÐµÑˆÐ°ÑŽÑ‚ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñƒ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð´Ð»Ð¸Ð½Ñ‹
ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð°, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ñ…Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð½Ð° Ð´Ð»Ñ ÐºÐ¾Ñ€Ñ‚ÐµÐ¶ÐµÐ¹, Ð½Ð¾ ÑÐ¿Ð¸ÑÐºÐ¸ Ð¼Ð¾Ð³ÑƒÑ‚ ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾
Ð¾Ð´Ð¸Ð½ Ñ‚Ð¸Ð¿ (Ð´Ñ€ÑƒÐ³Ð¸Ð¼Ð¸ ÑÐ»Ð¾Ð²Ð°Ð¼Ð¸, Ð¾Ð½Ð¸ Ð¾Ð´Ð½Ð¾Ñ€Ð¾Ð´Ð½Ñ‹). Ð¡Ð¿Ð¸ÑÐºÐ¸ Ñ‚Ð°ÐºÐ¶Ðµ Ð¸Ð¼ÐµÑŽÑ‚ ÑÐ¿ÐµÑ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ð¹
Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ð½Ñ‹Ð¹ ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ.

```haskell
ghci> [1,2,3,4]
[1,2,3,4]
```

### Ð˜Ð½Ð´ÑƒÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ñ‚Ð¸Ð¿Ñ‹

Ð¡Ð¿Ð¸ÑÐºÐ¸ Ð½Ð°Ñ‡Ð¸Ð½Ð°ÑŽÑ‚ Ð½Ð°ÑˆÐµ Ð·Ð½Ð°ÐºÐ¾Ð¼ÑÑ‚Ð²Ð¾ Ñ Â«Ð¸Ð½Ð´ÑƒÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¼Ð¸Â» Ð¸Ð»Ð¸ Â«Ñ€ÐµÐºÑƒÑ€ÑÐ¸Ð²Ð½Ñ‹Ð¼Ð¸Â» Ñ‚Ð¸Ð¿Ð°Ð¼Ð¸.
ÐŸÐ¾ÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ð¼ Ð½Ð° ÐºÐ¾Ð´, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ‡ÐµÐ½ Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ð½Ð¾Ð¹ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Haskell, Ð½Ð¾ Ð±ÐµÐ·
ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸Ñ‡ÐµÑÐºÐ¾Ð³Ð¾ ÑÐ°Ñ…Ð°Ñ€Ð°.

```haskell
data List a = Nil | Cons a (List a)
```

Ð—Ð°Ð¼ÐµÑ‚Ð¸Ð¼, Ñ‡Ñ‚Ð¾ ÑÑ‚Ð¾Ñ‚ Ñ‚Ð¸Ð¿ Ñ€ÐµÐºÑƒÑ€ÑÐ¸Ð²Ð½Ñ‹Ð¹: `Nil` ÑÑ‚Ð¾ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¹ ÑÐ»ÑƒÑ‡Ð°Ð¹, Ð° ÐºÐ¾Ð½ÑÑ‚Ñ€ÑƒÐºÑ‚Ð¾Ñ€
`Cons` Ð¾Ð±ÑŠÐµÐ´Ð¸Ð½ÑÐµÑ‚ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ `a` Ð¸ Ñ€ÐµÐºÑƒÑ€ÑÐ¸Ð²Ð½Ñ‹Ð¹ Ð²Ñ‹Ð·Ð¾Ð² `List a`. Ð¢Ð°ÐºÐ¶Ðµ Ð¿Ð¾Ð½ÑÑ‚Ð½Ð¾,
Ð¿Ð¾Ñ‡ÐµÐ¼Ñƒ ÑÐ¿Ð¸ÑÐºÐ¸ Ð¼Ð¾Ð³ÑƒÑ‚ ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ 1 Ñ‚Ð¸Ð¿: ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð° `a` Ð½Ð°Ð¿Ð¾Ð»Ð½ÑÑŽÑ‚
Ð²ÑÑŽ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð½Ð° ÐºÐ°Ð¶Ð´Ð¾Ð¼ ÑˆÐ°Ð³Ðµ Ñ€ÐµÐºÑƒÑ€ÑÐ¸Ð¸. Ð•ÑÐ»Ð¸ Ð² Ð´Ð°Ð½Ð½Ð¾Ð¼ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ð¸ `Nil`
Ð·Ð°Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ñ‹Ð¼ ÑÐ¿Ð¸ÑÐºÐ¾Ð¼ `[]`, Ð° `Cons` Ð·Ð°Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ `:`, Ñ‚Ð¾ Ð¼Ñ‹ Ð²ÐµÑ€Ð½Ñ‘Ð¼ÑÑ Ðº
Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ð½Ð¾Ð¼Ñƒ ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸ÑÑƒ.

ÐŸÑ€Ð¾Ð²ÐµÐ´Ñ‘Ð¼ Ð´ÐµÐ¼Ð¾Ð½ÑÑ‚Ñ€Ð°Ñ†Ð¸ÑŽ ÑÐ¿Ð¸ÑÐºÐ¾Ð² Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð²ÑÑ‚Ñ€Ð¾ÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ¸Ð½Ñ‚Ð°ÐºÑÐ¸ÑÐ°, Ð° Ñ‚Ð°ÐºÐ¶Ðµ
ÐºÐ¾Ð½ÑÑ‚Ñ€ÑƒÐºÑ‚Ð¾Ñ€Ð° `:` Ð¸, Ð½Ð°ÐºÐ¾Ð½ÐµÑ†, Ð½Ð°ÑˆÐµÐ³Ð¾ Ñ€ÑƒÑ‡Ð½Ð¾Ð³Ð¾ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ. Ð’ÑÐµ Ñ‚Ñ€Ð¸ Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð°
ÑÐºÐ²Ð¸Ð²Ð°Ð»ÐµÐ½Ñ‚Ð½Ñ‹:

```haskell
ghci> [1,2,3,4]
[1,2,3,4]
ghci> 1 : 2 : 3 : 4 : []
[1,2,3,4]
ghci> Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))
Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))
```

### ÐšÐ¾Ð³Ð´Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ

Ð¡Ð²ÑÐ·Ð½Ñ‹Ðµ ÑÐ¿Ð¸ÑÐºÐ¸ â€” Ñ‡Ñ€ÐµÐ·Ð²Ñ‹Ñ‡Ð°Ð¹Ð½Ð¾ Ñ€Ð°ÑÐ¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÐµÐ½Ð½Ð°Ñ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð² Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾Ð¼
Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ð¸, Ð° Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ Ð²Ñ‹ Ð²ÑÑ‚Ñ€ÐµÑ‚Ð¸Ñ‚Ðµ Ð¸Ñ… Ð¿Ð¾Ð²ÑÑŽÐ´Ñƒ Ð² Haskell. ÐžÐ±Ñ‹Ñ‡Ð½Ð¾ ÑÐ¿Ð¸ÑÐºÐ¸ ÑÑ‚Ð¾
Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€, Ðº ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð¼Ñƒ Ñ‚ÑÐ½ÐµÑ‚ÑÑ Ð¿Ñ€Ð¾Ð³Ñ€Ð°Ð¼Ð¼Ð¸ÑÑ‚ Ð½Ð° Haskell. Ð˜Ð·-Ð·Ð° Ð¼ÐµÐ´Ð»ÐµÐ½Ð½Ð¾Ð¹
ÐºÐ¾Ð½ÐºÐ°Ñ‚ÐµÐ½Ð°Ñ†Ð¸Ð¸ Ð¸ Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¼ÐµÐ´Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¸Ð½Ð´ÐµÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ (ð›° (n), Ð³Ð´Ðµ n ÑÑ‚Ð¾
Ð¸Ð½Ð´ÐµÐºÑ), Ð¾Ð½Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‚ÑÑ Ð² ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸ÑÑ…, ÐºÐ¾Ð³Ð´Ð° Ð¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾, Ñ‡Ñ‚Ð¾ Ð²Ð°Ð¼ Ð¿Ñ€Ð¸Ð´ÐµÑ‚ÑÑ
Ð¿Ñ€Ð¾Ð¹Ñ‚Ð¸ÑÑŒ Ð¿Ð¾ Ð²ÑÐµÐ¼Ñƒ Ð½Ð°Ð±Ð¾Ñ€Ñƒ Ð´Ð°Ð½Ð½Ñ‹Ñ…, Ð¸Ð»Ð¸ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¿Ð¾Ñ€ÑÐ´Ð¾Ðº ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð².

ÐžÑ‚Ð»Ð¸Ñ‡Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¸Ð¼ÐµÑ€ Ð°Ð±ÑÑ‚Ñ€Ð°ÐºÑ‚Ð½Ð¾Ð¹ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…, Ð´Ð»Ñ ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð¹ ÑÐ²ÑÐ·Ð½Ñ‹Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº Ñ…Ð¾Ñ€Ð¾ÑˆÐ¾
Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ð¸Ñ‚ Ð² ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ðµ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¹ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸, ÑÑ‚Ð¾ ÑÑ‚ÐµÐºÐ¸. Ð’ÑÑ‘ Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ Ñ‡Ñ‚Ð¾ `push` Ð¸
`pop` Ð¸Ð¼ÐµÑŽÑ‚ Ð² Ñ‚Ð°ÐºÐ¾Ð¼ ÑÐ»ÑƒÑ‡Ð°Ðµ ÑÐ»Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ ð›° (1).

ÐŸÐ»Ð¾Ñ…Ð¸Ð¼ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ð¾Ð¼ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÐ¿Ð¸ÑÐºÐ° Ð±ÑƒÐ´ÐµÑ‚ Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ, Ð³Ð´Ðµ Ð»Ð¸Ð±Ð¾ Ð¿Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð²
Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ, Ð»Ð¸Ð±Ð¾ Ð¸Ð·Ð²Ð»ÐµÑ‡ÑŒ Ð¸Ð· Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð¸ Ð·Ð°Ð¹Ð¼Ñ‘Ñ‚ ð›° (n) (Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸ Ð¾Ñ‚ Ñ‚Ð¾Ð³Ð¾, Ñ ÐºÐ°ÐºÐ¾Ð¹
ÑÑ‚Ð¾Ñ€Ð¾Ð½Ñ‹ ÑÐ²ÑÐ·Ð½Ð¾Ð³Ð¾ ÑÐ¿Ð¸ÑÐºÐ° Ð²Ñ‹ Ñ€ÐµÑˆÐ¸Ð»Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑ‚ÑŒ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹).

Ð Ð°ÑÐ¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÐµÐ½Ð½Ñ‹Ð¹ Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ñ€Ð¸Ð¼ÐµÑ€ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÐ¿Ð¸ÑÐºÐ¾Ð² ÑÑ‚Ð¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÑ‹ Ðº Ð±Ð°Ð·Ðµ
Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð² Ð¿Ð°Ð¼ÑÑ‚Ð¸. Ð—Ð°Ð¿Ñ€Ð¾Ñ Ðº Ñ‚Ð°ÐºÐ¾Ð¹ Ð±Ð°Ð·Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð½Ðµ Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð° `[]` Ð¸Ð»Ð¸
Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¿Ð¾Ñ‚ÐµÐ½Ñ†Ð¸Ð°Ð»ÑŒÐ½Ð¾ ÑƒÐ¿Ð¾Ñ€ÑÐ´Ð¾Ñ‡ÐµÐ½Ð½Ñ‹Ñ… Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² `[entity ..]`. Ð¢Ð°ÐºÐ°Ñ
Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ° Ð´Ð»Ñ Ð±Ð°Ð· Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð½Ðµ Ð±ÑƒÐ´ÐµÑ‚ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ñ‹Ð²Ð°Ñ‚ÑŒ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ð¿Ð¾ Ð¸Ð½Ð´ÐµÐºÑÑƒ Ð¸ Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚
ÑÑ‚Ð¾ Ð½Ð° ÑƒÑÐ¼Ð¾Ñ‚Ñ€ÐµÐ½Ð¸Ðµ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð°.

### ÐšÐ¾Ð½ÐºÐ°Ñ‚ÐµÐ½Ð°Ñ†Ð¸Ñ ÑÐ¿Ð¸ÑÐºÐ¾Ð²

Ð”Ð»Ñ ÐºÐ¾Ð½ÐºÐ°Ñ‚ÐµÐ½Ð°Ñ†Ð¸Ð¸ ÑÐ¿Ð¸ÑÐºÐ¾Ð² Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ñ `++`:

```haskell
ghci> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

### Ð“Ð¾Ð»Ð¾Ð²Ð° Ð¸ Ñ…Ð²Ð¾ÑÑ‚

ÐŸÑ€Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ð¸ ÑÐ¿Ð¸ÑÐºÐ¾Ð² Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ Ð¾Ð±Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÑŽÑ‚ Ð³Ð¾Ð»Ð¾Ð²Ñƒ Ð¸ Ñ…Ð²Ð¾ÑÑ‚ ÑÐ¿Ð¸ÑÐºÐ°. Ð“Ð¾Ð»Ð¾Ð²Ð° ÑÑ‚Ð¾
Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ ÑÐ¿Ð¸ÑÐºÐ°, Ð° Ñ…Ð²Ð¾ÑÑ‚ ÑÑ‚Ð¾ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ… Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð².

Haskell Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ Ð´Ð²Ðµ Ð¿Ð¾Ð»ÐµÐ·Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ ÑÑ‚Ð¸Ð¼Ð¸ Ñ‡Ð°ÑÑ‚ÑÐ¼Ð¸, `head` Ð¸
`tail`:

```haskell
ghci> head ["Orange", "Banana", "Apple"]
"Orange"
ghci> tail ["Orange", "Banana", "Apple"]
["Banana","Apple"]
```

Ðš ÑÐ¾Ð¶Ð°Ð»ÐµÐ½Ð¸ÑŽ, ÑÑ‚Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ñ€Ð°ÑÐºÑ€Ñ‹Ð²Ð°ÑŽÑ‚ Ð½ÐµÐ¿Ñ€Ð¸Ð³Ð»ÑÐ´Ð½ÑƒÑŽ ÑÑ‚Ð¾Ñ€Ð¾Ð½Ñƒ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ð¹ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ¸
ÑÐ·Ñ‹ÐºÐ° (`base`): Ð³Ð¾Ð»Ð¾Ð²Ð° Ð¸ Ñ…Ð²Ð¾ÑÑ‚ Ð¼Ð¾Ð³ÑƒÑ‚ Ð²Ñ‹Ð·Ð²Ð°Ñ‚ÑŒ Ð¸ÑÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ, Ð´Ð°Ð¶Ðµ ÐµÑÐ»Ð¸ Ð¸Ð¼ Ð¿ÐµÑ€ÐµÐ´Ð°Ð½
Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚ Ð½ÑƒÐ¶Ð½Ð¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð°. ÐŸÑ€Ð¸Ñ‡Ð¸Ð½Ð° Ð² Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ ÑÑ‚Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð½Ðµ Ð¿Ð¾ÐºÑ€Ñ‹Ð²Ð°ÑŽÑ‚ Ð²ÑÑ‘
Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²Ð¾ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ñ… Ð²Ñ…Ð¾Ð´Ð¾Ð².

```haskell
ghci> head []
*** Exception: Prelude.head: empty list
ghci> tail []
*** Exception: Prelude.tail: empty list
```

Ð’ Haskell Ñ€Ð°ÑÐ¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÐµÐ½Ð° Ð¸Ð´Ð¸Ð¾Ð¼Ð° Ð´Ð»Ñ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð¹ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ñ‹Ð¼Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑÐ¼Ð¸ â€”
Ñ‚Ð¸Ð¿ `Maybe`. ÐžÐ½ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ ÑÐºÐ°Ð·Ð°Ñ‚ÑŒ, Ñ‡Ñ‚Ð¾ Ð½ÐµÐ¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ñ€Ð¸Ð²Ð¾Ð´ÑÑ‚ Ðº
Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸ÑŽ `Nothing` Ð½Ð° Ð²Ñ‹Ñ…Ð¾Ð´Ðµ. ÐŸÑ€Ð¸ Ñ‚Ð°ÐºÐ¾Ð¼ Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ðµ Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÑŽÑ‰Ð°Ñ ÑÑ‚Ð¾Ñ€Ð¾Ð½Ð° Ð¾Ð±ÑÐ·Ð°Ð½Ð°
Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ ÑÐ»ÑƒÑ‡Ð°Ð¹ `Nothing`, Ð½Ð¾ Ð²Ð·Ð°Ð¼ÐµÐ½ Ð¼Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð·Ð°Ñ‰Ð¸Ñ‚Ñƒ Ð¾Ñ‚ Ð½ÐµÐ¿Ñ€Ð¸ÑÑ‚Ð½Ð¾Ð¹
Ð¸ÑÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ð¹ ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸Ð¸ Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ.

```haskell
ghci> :i Maybe
data Maybe a = Nothing | Just a   -- Defined in â€˜GHC.Maybeâ€™
...
```
__Ð—Ð°Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ__: `:i` Ð² GHCi Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÑ‚ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ñ‚Ð¸Ð¿Ðµ; Ð¿ÐµÑ€Ð²Ð°Ñ ÑÑ‚Ñ€Ð¾ÐºÐ° ÑÑ‚Ð¾ Ñ€ÐµÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ.

ÐŸÐ¾ÐºÐ°Ð¶ÐµÐ¼ ÐºÐ°Ðº Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ñ‚Ð¾Ñ‚Ð°Ð»ÑŒÐ½ÑƒÑŽ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ Ð³Ð¾Ð»Ð¾Ð²Ñ‹ Ð¸ Ñ…Ð²Ð¾ÑÑ‚Ð° Ð¿Ñ€Ð¸ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð¸
ÑÐ¾Ð¿Ð¾ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ Ð¾Ð±Ñ€Ð°Ð·Ñ†Ð¾Ð¼ Ð¸ `Maybe`.

```haskell
ghci> :{
| safeHead :: [a] -> Maybe a
| safeHead [] = Nothing
| safeHead (x:xs) = Just x
|
| safeTail :: [a] -> Maybe [a]
| safeTail [] = Nothing
| safeTail (x:xs) = Just xs
| :}
ghci> safeHead ["Orange", "Banana", "Apple"]
Just "Orange"
ghci> safeHead []
Nothing
ghci> safeTail ["Orange", "Banana", "Apple"]
Just ["Banana","Apple"]
ghci> safeTail []
Nothing
```
__Ð—Ð°Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ__: `:{` Ð¸ `:}` Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑŽÑ‚ Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð¼Ð½Ð¾Ð³Ð¾ÑÑ‚Ñ€Ð¾Ñ‡Ð½Ñ‹Ðµ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð² GHCi.

Ð‘Ð¾Ð»ÑŒÑˆÐµ Ð½Ð¸ÐºÐ°ÐºÐ¸Ñ… Ð¸ÑÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¹!

Ð”Ñ€ÑƒÐ³Ð¾Ð¹ ÑÐ¿Ð¾ÑÐ¾Ð± Ð¾Ð±ÐµÑÐ¿ÐµÑ‡Ð¸Ñ‚ÑŒ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚ÑŒ `head` Ð¸ `tail` ÑÑ‚Ð¾ Ñ‚Ð¸Ð¿ Ð½ÐµÐ¿ÑƒÑÑ‚Ð¾Ð³Ð¾ ÑÐ¿Ð¸ÑÐºÐ°:

```haskell
ghci> import Data.List.NonEmpty
ghci> :i NonEmpty
data NonEmpty a = a .:| [a]
```

Ð˜Ð· Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð²Ð¸Ð´Ð½Ð¾, Ñ‡Ñ‚Ð¾ `NonEmpty` Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ñ Ð¿ÐµÑ€Ð²Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°. Ð¡Ð¸Ð¼Ð²Ð¾Ð»
`:|` ÑÐ²Ð»ÑÐµÑ‚ÑÑ ÐºÐ¾Ð½ÑÑ‚Ñ€ÑƒÐºÑ‚Ð¾Ñ€Ð¾Ð¼, Ð°Ð½Ð°Ð»Ð¾Ð³Ð¸Ñ‡Ð½Ð¾ `:`; Ñ„Ð°ÐºÑ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ `NonEmpty`
ÑÐºÐ²Ð¸Ð²Ð°Ð»ÐµÐ½Ñ‚Ð½Ð¾ ÑÐ¿Ð¸ÑÐºÐ°Ð¼ Ð½Ð¾ Ð¸ÑÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ ÑÐ»ÑƒÑ‡Ð°Ð¹ Ð¿ÑƒÑÑ‚Ð¾Ð³Ð¾ ÑÐ¿Ð¸ÑÐºÐ°.

Ð¢Ð°ÐºÐ¾Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ð¿Ñ€ÑÐ¼Ð¾ Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð¾Ð¿Ð¾Ð»Ð¾Ð¶Ð½Ð¾ Ñ€ÐµÑˆÐµÐ½Ð¸ÑŽ Ñ
`Maybe`. Ð’Ð¼ÐµÑÑ‚Ð¾ Ñ‚Ð¾Ð³Ð¾, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð·Ð°ÑÑ‚Ð°Ð²Ð»ÑÑ‚ÑŒ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð° Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð·Ð°Ñ‰Ð¸Ñ‰Ð°Ñ‚ÑŒÑÑ Ð¾Ñ‚
Ð½ÐµÐ¶ÐµÐ»Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ð³Ð¾ ÑÐ»ÑƒÑ‡Ð°Ñ Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐµÑ‘ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð°, Ð¼Ñ‹ Ð·Ð°ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð¿Ñ€ÐµÐ´Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ
Ð¸Ð·Ð½Ð°Ñ‡Ð°Ð»ÑŒÐ½Ð¾ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ Ð²Ñ…Ð¾Ð´ (Ð¿Ñ€Ð¸ Ð²Ñ‹Ð·Ð¾Ð²Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸).

```haskell
ghci> import Data.List.NonEmpty as NE
ghci> :t NE.head
NE.head :: NonEmpty a -> a
ghci> head (1 :| [])
1
ghci> NE.head []
<interactive>:11:9: error:
    â€¢ Couldn't match expected type: NonEmpty a
                  with actual type: [a]
    ...
```

ÐžÐ±Ñ€Ð°Ñ‚Ð¸Ñ‚Ðµ Ð²Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ, Ñ‡Ñ‚Ð¾ Ð½Ð° ÑÑ‚Ð¾Ñ‚ Ñ€Ð°Ð· Ð¾ÑˆÐ¸Ð±ÐºÐ° ÑÑ‚Ð¾ Ð½Ðµ Ð¸ÑÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ,
Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ñ‚Ð¸Ð¿Ð¾Ð²; ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑ‚Ð¾Ñ€ ÑÐ¾Ð¾Ð±Ñ‰Ð°ÐµÑ‚, Ñ‡Ñ‚Ð¾ Ð¼Ñ‹ Ð¿Ñ‹Ñ‚Ð°Ð»Ð¸ÑÑŒ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ
(Ð¿Ð¾Ñ‚ÐµÐ½Ñ†Ð¸Ð°Ð»ÑŒÐ½Ð¾ Ð¿ÑƒÑÑ‚Ð¾Ð¹) ÑÐ¿Ð¸ÑÐ¾Ðº, Ð° Ð½Ðµ Ñ‚Ñ€ÐµÐ±ÑƒÐµÐ¼Ñ‹Ð¹ Ñ‚Ð¸Ð¿ `NonEmpty`.

### List Performance

Haskell implements lists as linked lists. The cons cells (the operator `:` is
called cons, short for constructor) act as the links. This dictates which
operations can be done quickly and which can be slow:

Prepending a value to a list is easy and fast - all we have to do is create a
new cons cell with the element we want to prepend and point it to the existing
list.

```haskell
prepend value list = value : list
```

On the other hand, since the list data type (as shown above) can be either
empty (`[]` or `Nil`) or a cons cell that will point to the rest of the list,
it does not contain information about the length of the list, or a reference to
the end of the list.

Because of that, in order to retrieve the length of a list we must walk
each cons cell and count until we reach the end of the list. To find the
value at a specific index we need to traverse the list until we reach it.

Similarly, in order to append a list to an existing list, we need to go to the
end of the existing list, and add a cons cell that points to the new list:

```haskell
append originalList newList =
    case originalList of
        [] -> newList
        x : xs -> x : append xs newList
```

The append function defined here is really the same as the `++` operator, as you
might have deduced we need to be careful when using list append. Particularly
`++` inside of loops has quadratic performance!

By virtue of the linked list data structure, many list operations run in linear
time (`ð›°(n)`). In many cases the same operation is significantly slower for
lists than for other containers, this is a great reason to be familiar with each
and their tradeoffs!

## Assoc lists

So far we have only been able to access values via position indexed lookup, or
pattern matching. However, one of the most common use cases for containers is
acting as a key value store. Assoc(iation) lists provide this by combining
2-tuples and regular lists. Since assoc lists are really just the combination
of two existing data types, the only thing we need is a lookup function, which
is provided in the `Data.List` module in base.

```haskell
ghci> import Data.List as List
ghci> assoc = [("foo", True), ("bar", False)]
ghci> :t assoc
assoc :: [(String, Bool)]
ghci> :t List.lookup
List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
ghci> List.lookup "foo" assoc
Just True
ghci> List.lookup "bar" assoc
Just False
ghci> List.lookup "baz" assoc
Nothing
```

We can see the pattern, again, where no result is encoded using the `Maybe`
type. This is because it is always *possible* that the key are looking up isn't
present in our assoc list.

It is also interesting to note the `Eq a` constraint on the "key" which allows
the lookup function to do an equality comparison on them.

While assoc lists are a nice introduction to key value containers, and they
build on the previous types we learned about, they are not particularly useful.
A list simply isn't a very good data structure for lookup, as it provides worst
case `ð›°(n)` asymptotics. Assoc lists are usually an intermediate data structure
which Haskell programmers will convert into a `Map`. Although this conversion
is itself an `ð›°(n*log n)` operation `Map` provides an `ð›°(log n)` lookup, so the
conversion cost is amortised very quickly.

## Sets

Sets are a very interesting container, the core concept of a set is membership.
It is common to build up sets, and then test to see if an element exists in that
set.

A set can be constructed exclusively by inserting elements into the empty set

```haskell
ghci> import Data.Set as Set
ghci> :t Set.empty
Set.empty :: Set a
ghci> Set.empty
fromList []
ghci> Set.insert 1 (Set.insert 2 (Set.insert 3 Set.empty))
fromList [1,2,3]
```

Or by creating a set from a list

```haskell
ghci> Set.fromList [4,3,2,1]
fromList [1,2,3,4]
```

You might notice that the elements are sorted after turning them into a `Set`.
Internally the `Set` data type depends on its contents being orderable. The
concrete implementation of sets in Haskell are binary trees, which depend on an
ordering. We can see the ordering requirement from the constraints on the
`insert` and `fromList` (and other) functions.

```haskell
ghci> :t Set.insert
Set.insert :: Ord a => a -> Set a -> Set a
ghci> :t Set.fromList
Set.fromList :: Ord a => [a] -> Set a
ghci> :t Set.member
Set.member :: Ord a => a -> Set a -> Bool
```

Sets have a very useful property, they cannot contain duplicates.

```haskell
ghci> insert1 = Set.insert 1
ghci> insert1 Set.empty
fromList [1]
ghci> insert1 (insert1 Set.empty)
fromList [1]
ghci> insert1 (insert1 (insert1 Set.empty))
fromList [1]
```

Alright, let's see an almost-practical use case for sets.

```haskell
ghci> evens = Set.fromList [0,2..1000000]
ghci> Set.member 7 evens
False
ghci> Set.member 200012 evens
True
ghci> isEven n = Set.member n evens
ghci> isEven 7
False
ghci> isEven 8
True
```

You might say "hmmm a `1000000` limit for even numbers seems incorrect", and you
would be right! This highlights a property of sets in haskell, they are finite
due to the strictness in the underlying data structure. This contrasts lists,
which are lazy and therefore potentially infinite.

### Set Operations

Set difference is a good way to break apart a set based on the membership of its
elements in another set. It will return a set with all the elements of the first
argument less the elements of its second argument.

```haskell
ghci> set1 = Set.fromList ["a", "b", "c", "1", "2", "3"]
ghci> letters = Set.fromList ["a", "b", "c"]
ghci> nums = Set.fromList ["1", "2", "3"]
ghci> Set.difference set1 letters
fromList ["1","2","3"]
ghci> Set.difference set1 nums
fromList ["a","b","c"]
```

Union's are useful for when we want to build up a new set from the combination
of two other sets.

```haskell
ghci> nums
fromList ["1","2","3"]
ghci> letters
fromList ["a","b","c"]
ghci> Set.union nums letters
fromList ["1","2","3","a","b","c"]
ghci> set1
fromList ["1","2","3","a","b","c"]
ghci> Set.union nums set1
fromList ["1","2","3","a","b","c"]
```

Intersection allows us to find elements that sets have in common.

```haskell
ghci> Set.intersection nums letters
fromList []
ghci> Set.intersection nums set1
fromList ["1","2","3"]
ghci> Set.intersection letters set1
fromList ["a","b","c"]
ghci> Set.intersection (fromList [1, 2]) (fromList [2, 3])
fromList [2]
```

Subsets allow us to detect if all the elements of a set are contained within
another set.

```haskell
ghci> Set.isSubsetOf letters set1
True
ghci> Set.isSubsetOf nums set1
True
ghci> Set.isSubsetOf nums letters
False
ghci> Set.isSubsetOf set1 nums
False
```

Every set is a subset of itself.

```haskell
ghci> Set.isSubsetOf nums nums
True
ghci> Set.isSubsetOf set1 set1
True
ghci> Set.isSubsetOf letters letters
True
```

## Maps

In Haskell, maps are the "go-to" key-value store, sometimes referred to as a
dictionary.

A `Map` requires that its key has an ordering (`Ord k`), in the same way that
`Set` required an ordering on the value. This is because the internal
implementation of the `Map` type in Haskell is a size balanced binary tree. This
is actually the same data structure as is used for `Set`.

The `Map` data type and the functions for interacting with it are exported from
`Data.Map` which is a module in the `containers` package. Don't worry about
dependencies though, containers is a core library and ships with ghci.

Like sets, a map can be constructed by inserting key value pairs into an empty map

```haskell
ghci> import Data.Map (Map)
ghci> import qualifide Data.Map as Map
ghci> :t Map.empty
Map.empty :: Map k a
ghci> Map.empty
fromList []
ghci> Map.insert "a" 'a' (Map.insert "b" 'b' (Map.insert "c" 'c' Map.empty))
fromList [("a",'a'),("b",'b'),("c",'c')]
```

Or by creating it from a list

```haskell
ghci> Map.fromList [(4, '4'), (3, '3'), (2, '2'), (1,'1')]
fromList [(1,'1'),(2,'2'),(3,'3'),(4,'4')]
```

## Updating Values to a Map

A useful function to be aware of is `adjust`. This lets us update a value at a
specified key, only if it exists, if not the old map is returned.

```haskell
ghci> Map.adjust (+2) "first" oneItem
fromList [("first",3)]
ghci> :t Map.adjust
Map.adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
ghci> Map.adjust (+2) "second" oneItem
fromList [("first",1)]
```

The observant reader will notice that `adjust` doesn't actually update the map.
The second invocation of adjust returns the original `oneItem` map, this makes
sense when you consider that all data in Haskell is immutable!

## When to use Maps

Maps are really great for in memory persistence of state that will need to be
retrieved by a key of some arbitrary type. This is is because maps have great
lookup asymptotics (`ð›°(log n)`) due to the ordering on the key values. The
example that immediately springs to mind is session storage on the server in a
web application. The session state can be indexed by an id that is stored in
the cookie, and the session state can be retrieved from an in memory `Map` on
every request. This solution doesn't scale infinitely, but you would be
surprised how well it works!

## HashMaps

There are some cases where we do not have an ordering on our type, but still
want to use it as a key to index a map. In this case we probably want to reach
for a hashmap. A hashmap simply hashes the key, et voilÃ , we have an ordering!
This does require that the key type is hashable though.

The module that exports the `HashMap` data type and functionality is called
`Data.HashMap.Strict`, it lives in the `unordered-containers` package. The api
is identical to `Map` aside from a `Hashable k` constraint instead of an `Ord k`
on the key.

## Vectors

Sometimes we want a list like container where we can have performant indexed
access. In fact arrays are often the primitive sequential data structure in
lots of popular programming langauges. Haskell has this kind of data structures
too, and the most popular implementation is the `Vector` type from the `vector`
library.

One of the coolest things about the `Vector` type is that it offers `ð›°(1)`
indexed access. The `vector` library offers both a safe and unsafe index
accessor operator.

Here is an example where we want to create a container that allows us to
retrieve ascii chars by their character code.

__Note__: You can fetch the `vector` library using `cabal repl --build-depends "vector"`
or `stack exec --package vector -- ghci`

```haskell
ghci> import Data.Vector as V
ghci> asciiChars = V.fromList ['\NUL'..'\DEL']
ghci> asciiChars ! 48
'0'
ghci> asciiChars ! 97
'a'
ghci> asciiChars ! 65
'A'
ghci> asciiChars !? 65
Just 'A'
ghci> asciiChars !? 128
Nothing
ghci> asciiChars !? 127
Just '\DEL'
```

Vectors also offer efficient slicing `ð›°(1)`, so they are really good for
creating sub-vectors. The slice function takes the index to start at, the
length of the slice, and the vector to slice, and returns a new vector. Slicing
is unsafe, if the starting index plus the length of the slice exceeds the vector
you will get a runtime error.

```haskell
ghci> :t V.slice
V.slice :: Int -> Int -> Vector a -> Vector a
ghci> lowerCase = V.slice 97 26 asciiChars
ghci> lowerCase
"abcdefghijklmnopqrstuvwxyz"
ghci> upperCase = V.slice 65 26 asciiChars
ghci> upperCase
"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
ghci> nums = V.slice 48 10 asciiChars
ghci> V.length nums
128
ghci> nums
"0123456789"
-- Error case, the asciiChars vectors has length 128, and our slice supposes a
-- length of 97 + 92 (189)
ghci> V.slice 97 92 asciiChars
"*** Exception: ./Data/Vector/Generic.hs:408 (slice): invalid slice (97,92,128)
CallStack (from HasCallStack):
  error, called at ./Data/Vector/Internal/Check.hs:87:5 in vector-0.12.3.0-8cc976946fcdbc43a65d82e2ca0ef40a7bb90b17e6cc65c288a8b694f5ac3127:Data.Vector.Internal.Check
```

## Overloaded Lists

You may have noticed that we frequently use the `fromList` function to
construct our containers. There is a language extension that allows us to
simply use the list syntax to construct these containers. The drawback of
overloading the list syntax is that we can get confusing type errors if we are
not explicit about our types.

```haskell
ghci> :set -XOverloadedLists -- This is the language extension
ghci> [1,2,3] :: Set Int
fromList [1,2,3]
ghci> [1,2,3] :: Vector Int
[1,2,3]
ghci> [('a', 1),('b', 2),('c', 3)] :: Map Char Int
fromList [('a',1),('b',2),('c',3)]
```

However, if we aren't explicit about the type...

```haskell
ghci> ["1", "2", "3"]

<interactive>:11:1: error:
    â€¢ Illegal equational constraint GHC.Exts.Item l ~ [Char]
      (Use GADTs or TypeFamilies to permit this)
    â€¢ When checking the inferred type
        it :: forall {l}.
              (GHC.Exts.IsList l, GHC.Exts.Item l ~ [Char]) =>
              l
```

This error is a bit of a doozey, which is why this language extension is
typically not enabled by default. It is still good to be aware of it!
